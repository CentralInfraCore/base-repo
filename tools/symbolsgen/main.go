package main

import (
	"bytes"
	"fmt"
	"go/doc"
	"go/token"
	"log"
	"os"
	"sort"
	"strings"

	"golang.org/x/tools/go/packages"
)

const (
	allowFile  = "context/SYMBOLS.ALLOWPKGS"
	outputFile = "context/SYMBOLS.md"
)

// generateSymbols loads and processes Go packages based on the provided patterns
// and returns the generated symbols documentation as a byte slice.
func generateSymbols(pkgPatterns []string) ([]byte, error) {
	// 2. Load the packages, including their syntax trees
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax | packages.NeedTypes,
		Fset: token.NewFileSet(),
	}
	pkgs, err := packages.Load(cfg, pkgPatterns...)
	if err != nil {
		return nil, fmt.Errorf("failed to load packages: %w", err)
	}

	var output bytes.Buffer
	output.WriteString("# Public Symbols\n\n")
	output.WriteString("_*This file is automatically generated. Do not edit manually.*_\n\n")

	// 3. Process each package
	for _, pkg := range pkgs {
		if len(pkg.Errors) > 0 {
			// We don't return an error here, just log it, as some packages might have errors
			// but we still want to process the valid ones.
			log.Printf("Errors loading package %s: %v", pkg.Name, pkg.Errors)
			continue
		}

		output.WriteString(fmt.Sprintf("## Package: `%s`\n\n", pkg.PkgPath))

		// Use the AST provided by the packages.Load call
		p, err := doc.NewFromFiles(pkg.Fset, pkg.Syntax, pkg.PkgPath)
		if err != nil {
			return nil, fmt.Errorf("failed to create doc package for %s: %w", pkg.PkgPath, err)
		}

		// Process and write constants
		if len(p.Consts) > 0 {
			output.WriteString("### Constants\n\n")
			sort.Slice(p.Consts, func(i, j int) bool { return p.Consts[i].Names[0] < p.Consts[j].Names[0] })
			for _, c := range p.Consts {
				for _, name := range c.Names {
					output.WriteString(fmt.Sprintf("- `const %s`\n", name))
				}
			}
			output.WriteString("\n")
		}

		// Process and write variables
		if len(p.Vars) > 0 {
			output.WriteString("### Variables\n\n")
			sort.Slice(p.Vars, func(i, j int) bool { return p.Vars[i].Names[0] < p.Vars[j].Names[0] })
			for _, v := range p.Vars {
				for _, name := range v.Names {
					output.WriteString(fmt.Sprintf("- `var %s`\n", name))
				}
			}
			output.WriteString("\n")
		}

		// Process and write functions
		if len(p.Funcs) > 0 {
			output.WriteString("### Functions\n\n")
			sort.Slice(p.Funcs, func(i, j int) bool { return p.Funcs[i].Name < p.Funcs[j].Name })
			for _, f := range p.Funcs {
				output.WriteString(fmt.Sprintf("- `func %s`\n", f.Name)) // Simplified for now
			}
			output.WriteString("\n")
		}

		// Process and write types
		if len(p.Types) > 0 {
			output.WriteString("### Types\n\n")
			sort.Slice(p.Types, func(i, j int) bool { return p.Types[i].Name < p.Types[j].Name })
			for _, t := range p.Types {
				output.WriteString(fmt.Sprintf("- `type %s`\n", t.Name))
			}
			output.WriteString("\n")
		}
	}

	return output.Bytes(), nil
}

func main() {
	// 1. Read the allowlist of packages
	allowlist, err := os.ReadFile(allowFile)
	if err != nil {
		log.Fatalf("Failed to read allowlist file %s: %v", allowFile, err)
	}

	pkgPatterns := strings.Split(strings.TrimSpace(string(allowlist)), "\n")

	// Generate the symbol documentation
	output, err := generateSymbols(pkgPatterns)
	if err != nil {
		log.Fatalf("Failed to generate symbols: %v", err)
	}

	// 4. Write the output to the file
	if err := os.WriteFile(outputFile, output, 0644); err != nil {
		log.Fatalf("Failed to write to %s: %v", outputFile, err)
	}

	fmt.Printf("Successfully generated %s\n", outputFile)
}
